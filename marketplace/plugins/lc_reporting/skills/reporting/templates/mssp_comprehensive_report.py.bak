#!/usr/bin/env python3
"""
Comprehensive Organization Report Template
Generates detailed operational and security reports for organizations
"""

from limacharlie import Manager
import time
import json
import os
import sys
from datetime import datetime, timezone, timedelta
from collections import defaultdict, Counter
from jinja2 import Environment, FileSystemLoader


def generate_mssp_report(oid, time_range_days=7, output_format='html'):
    """
    Generate a comprehensive organization report

    Args:
        oid: Organization ID
        time_range_days: Number of days to analyze (default: 7)
        output_format: 'html' or 'markdown' or 'json'

    Returns:
        Formatted report as string
    """
    m = Manager(oid=oid)

    # Calculate time range
    end_time = int(time.time())
    start_time = end_time - (time_range_days * 24 * 3600)

    print(f"Generating comprehensive organization report for {time_range_days} days...")
    print(f"Time range: {datetime.fromtimestamp(start_time, tz=timezone.utc)} to {datetime.fromtimestamp(end_time, tz=timezone.utc)}")

    # Collect data
    data = {}

    # 1. Organization metadata
    print("\n[1/9] Collecting organization info...")
    data['org_info'] = m.getOrgInfo()

    # 2. Detailed sensor statistics
    print("[2/9] Collecting detailed sensor statistics...")
    all_sensors = list(m.sensors())
    online_sensors = m.getAllOnlineSensors()
    # online_sensors is a list of SIDs (strings), not dicts
    online_sids = set(online_sensors) if isinstance(online_sensors, list) else set()

    # Get platform breakdown properly - TWO PASS approach
    # Pass 1: Collect all hostnames for each platform code
    platform_hostnames = defaultdict(list)
    sensor_list = []

    for i, sensor in enumerate(all_sensors):
        if i % 100 == 0:
            print(f"  Processing sensor {i}/{len(all_sensors)}...")

        try:
            info = sensor.getInfo()
            platform_raw = info.get('plat', info.get('ext_plat', 'unknown'))
            hostname = info.get('hostname', 'N/A')
            is_online = sensor.sid in online_sids

            platform_hostnames[str(platform_raw)].append(hostname)
            sensor_list.append({
                'sid': sensor.sid,
                'hostname': hostname,
                'platform_raw': platform_raw,
                'online': is_online,
                'ext_ip': info.get('ext_ip', 'N/A'),
                'last_seen': info.get('last_seen', 0)
            })
        except Exception as e:
            platform_hostnames['error'].append('error')

    # Generate descriptive names for each platform code
    def get_platform_display_name(platform_raw, hostnames):
        """Generate human-readable name based on platform and hostname patterns"""
        platform_str = str(platform_raw)

        # Known string platforms
        if platform_str in ['windows', 'linux', 'macos', 'chrome']:
            return platform_str

        # Numeric platforms - analyze hostname patterns
        if isinstance(platform_raw, int) or platform_str.isdigit():
            # Count hostname patterns
            patterns = {
                'ext': sum(1 for h in hostnames if 'ext-' in h.lower()),
                'test': sum(1 for h in hostnames if 'test' in h.lower()),
                'slack': sum(1 for h in hostnames if 'slack' in h.lower()),
                'office': sum(1 for h in hostnames if 'office' in h.lower()),
                'defender': sum(1 for h in hostnames if 'defender' in h.lower()),
                'demo': sum(1 for h in hostnames if 'demo' in h.lower()),
            }

            # Determine primary category
            total = len(hostnames)
            if patterns['ext'] > total * 0.5:
                return 'LimaCharlie Extensions'
            elif patterns['test'] > total * 0.5:
                return 'Test/Parser Systems'
            elif patterns['slack'] > 0:
                return 'Slack Integration'
            elif patterns['office'] > 0:
                return 'Office365 Integration'
            elif patterns['defender'] > 0:
                return 'Defender Integration'
            elif patterns['demo'] > total * 0.5:
                return 'Demo Systems'
            else:
                # Generic adapter name with primary hostname hint
                primary = hostnames[0] if hostnames else 'unknown'
                return f'Adapter ({primary})'

        return platform_str

    # Pass 2: Assign display names and aggregate
    platform_code_to_name = {}
    for platform_raw, hostnames in platform_hostnames.items():
        display_name = get_platform_display_name(platform_raw, hostnames)
        platform_code_to_name[str(platform_raw)] = display_name

    # Build final aggregations
    platforms = defaultdict(int)
    online_platforms = defaultdict(int)
    sensor_details = []
    numeric_platform_samples = defaultdict(list)

    for sensor_info in sensor_list:
        platform_raw = sensor_info['platform_raw']
        platform_display = platform_code_to_name.get(str(platform_raw), str(platform_raw))

        platforms[platform_display] += 1
        if sensor_info['online']:
            online_platforms[platform_display] += 1

        # Track samples for numeric platforms
        if isinstance(platform_raw, int) or str(platform_raw).isdigit():
            if len(numeric_platform_samples[platform_raw]) < 5:
                numeric_platform_samples[platform_raw].append(sensor_info['hostname'])

        sensor_info['platform'] = platform_display
        sensor_details.append(sensor_info)

    data['sensor_stats'] = {
        'total': len(all_sensors),
        'online': len(online_sensors),
        'offline': len(all_sensors) - len(online_sensors),
        'online_percentage': round((len(online_sensors) / len(all_sensors) * 100) if all_sensors else 0, 1),
        'by_platform': dict(platforms),
        'online_by_platform': dict(online_platforms),
        'sensor_details': sensor_details[:20],  # Top 20 for report
        'numeric_platform_info': dict(numeric_platform_samples)  # For reference in report
    }

    # 3. Detection analysis
    print("[3/9] Analyzing detections...")
    try:
        detections = m.getHistoricDetections(start=start_time, end=end_time, limit=10000)

        detection_categories = defaultdict(int)
        detection_by_day = defaultdict(int)
        detection_by_rule = defaultdict(int)
        detection_by_sensor = defaultdict(int)
        detection_timeline = []
        detection_count = 0

        for det in detections:
            detection_count += 1
            # Category
            cat = det.get('cat', 'unknown')
            detection_categories[cat] += 1

            # Rule name - use 'source_rule' field which contains the actual rule name
            rule = det.get('source_rule', det.get('cat', 'unknown'))
            detection_by_rule[rule] += 1

            # Sensor
            sid = det.get('sid', 'unknown')
            detection_by_sensor[sid] += 1

            # Timeline
            ts = det.get('timestamp', det.get('ts', 0))
            if ts:
                try:
                    # Handle millisecond timestamps
                    if ts > 1000000000000:  # Milliseconds
                        ts = ts / 1000
                    day = datetime.fromtimestamp(ts, tz=timezone.utc).strftime('%Y-%m-%d')
                    detection_by_day[day] += 1
                    detection_timeline.append({
                        'timestamp': ts,
                        'date': day,
                        'category': cat,
                        'rule': rule,
                        'sid': sid
                    })
                except (ValueError, OSError) as e:
                    # Skip malformed timestamps
                    pass

        # Get top rules
        top_rules = sorted(detection_by_rule.items(), key=lambda x: x[1], reverse=True)[:10]
        top_sensors = sorted(detection_by_sensor.items(), key=lambda x: x[1], reverse=True)[:10]

        data['detection_summary'] = {
            'total': detection_count,
            'by_category': dict(detection_categories),
            'by_day': dict(sorted(detection_by_day.items())),
            'top_rules': top_rules,
            'top_sensors': top_sensors,
            'avg_per_day': round(detection_count / time_range_days, 1) if time_range_days > 0 else 0,
            'timeline': detection_timeline[:100]  # Last 100
        }
    except Exception as e:
        print(f"  Error collecting detections: {e}")
        data['detection_summary'] = {'error': str(e), 'total': 0}

    # 4. Usage statistics with time series
    print("[4/9] Collecting usage statistics...")
    try:
        usage = m.getUsageStats()
        if 'usage' in usage:
            # Filter to our date range
            start_date = datetime.fromtimestamp(start_time, tz=timezone.utc).strftime('%Y-%m-%d')
            end_date = datetime.fromtimestamp(end_time, tz=timezone.utc).strftime('%Y-%m-%d')

            filtered_usage = {}
            for date, stats in usage['usage'].items():
                if start_date <= date <= end_date:
                    filtered_usage[date] = stats

            # Calculate trends - combined timeline for Mermaid charts
            event_timeline = []

            for date in sorted(filtered_usage.keys()):
                stats = filtered_usage[date]
                event_timeline.append({
                    'date': date,
                    'events': stats.get('sensor_events', 0),
                    'evaluations': stats.get('replay_num_evals', 0),
                    'output_gb': round(stats.get('output_bytes_tx', 0) / (1024**3), 3)
                })

            # Latest day stats
            if filtered_usage:
                latest_date = max(filtered_usage.keys())
                latest_stats = filtered_usage[latest_date]
            else:
                latest_date = 'N/A'
                latest_stats = {}

            data['usage_summary'] = {
                'date_range': f"{start_date} to {end_date}",
                'latest_date': latest_date,
                'latest_stats': {
                    'sensor_events': latest_stats.get('sensor_events', 0),
                    'detections_generated': latest_stats.get('replay_num_evals', 0),
                    'output_bytes_gb': round(latest_stats.get('output_bytes_tx', 0) / (1024**3), 2),
                    'peak_sensors': latest_stats.get('sensor_watermark', 0)
                },
                'timeline': {
                    'events': event_timeline  # Combined timeline with all metrics
                },
                'totals': {
                    'total_events': sum(s.get('sensor_events', 0) for s in filtered_usage.values()),
                    'total_output_gb': round(sum(s.get('output_bytes_tx', 0) for s in filtered_usage.values()) / (1024**3), 2),
                    'total_evaluations': sum(s.get('replay_num_evals', 0) for s in filtered_usage.values())
                }
            }
    except Exception as e:
        print(f"  Error collecting usage: {e}")
        data['usage_summary'] = {'error': str(e)}

    # 5. D&R Rule effectiveness
    print("[5/9] Analyzing D&R rules...")
    try:
        rules = m.rules()
        namespace_counts = defaultdict(int)

        for rule_path in rules.keys():
            # Extract namespace from rule path (e.g., "namespace/rule_name")
            if '/' in rule_path:
                namespace = rule_path.split('/')[0]
            else:
                namespace = 'general'
            namespace_counts[namespace] += 1

        data['dr_rules'] = {
            'total': len(rules),
            'by_namespace': dict(namespace_counts),
            'sample_rules': list(rules.keys())[:10]
        }
    except Exception as e:
        data['dr_rules'] = {'error': str(e), 'total': 0}

    # 6. False positive analysis
    print("[6/9] Checking false positive rules...")
    try:
        fps = m.fps()
        data['false_positives'] = {
            'total': len(fps),
            'rules': list(fps.keys())[:20]
        }
    except Exception as e:
        data['false_positives'] = {'error': str(e), 'note': 'Requires fp.ctrl permission'}

    # 7. Output health
    print("[7/9] Checking outputs...")
    try:
        outputs = m.outputs()
        output_types = defaultdict(int)

        for output_name, output_config in outputs.items():
            output_type = output_config.get('module', 'unknown') if isinstance(output_config, dict) else 'unknown'
            output_types[output_type] += 1

        data['outputs'] = {
            'total': len(outputs),
            'by_type': dict(output_types),
            'output_names': list(outputs.keys())[:10]
        }
    except Exception as e:
        data['outputs'] = {'error': str(e), 'total': 0}

    # 8. Tags analysis
    print("[8/9] Analyzing tags...")
    try:
        all_tags = m.getAllTags()
        # Count sensors per tag
        tag_usage = {}
        for tag in all_tags[:20]:  # Top 20 tags
            try:
                sensors_with_tag = list(m.sensorsWithTag(tag))
                tag_usage[tag] = len(sensors_with_tag)
            except:
                pass

        data['tags'] = {
            'total': len(all_tags),
            'top_tags': sorted(tag_usage.items(), key=lambda x: x[1], reverse=True)[:10]
        }
    except Exception as e:
        data['tags'] = {'error': str(e), 'total': 0}

    # 9. Configuration summary
    print("[9/9] Collecting configuration summary...")
    try:
        data['config_summary'] = {
            'users': len(m.getUsers()),
            'api_keys': len(m.getApiKeys())
        }
    except Exception as e:
        data['config_summary'] = {'error': str(e)}

    # Add metadata
    data['report_metadata'] = {
        'generated_at': datetime.now(timezone.utc).isoformat(),
        'time_range_days': time_range_days,
        'start_date': datetime.fromtimestamp(start_time, tz=timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC'),
        'end_date': datetime.fromtimestamp(end_time, tz=timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')
    }

    print("\n‚úì Data collection complete. Formatting report...")

    # Format output
    if output_format == 'json':
        return json.dumps(data, indent=2)
    else:
        return render_report(data, output_format)


def render_report(data, output_format='html'):
    """
    Render report using Jinja2 templates with Mermaid charts

    Args:
        data: Dictionary of report data
        output_format: 'html', 'markdown', or 'pdf'

    Returns:
        Rendered report as string (or bytes for PDF)
    """
    # For PDF, first render as HTML then convert
    template_format = 'html' if output_format == 'pdf' else output_format

    # Get template directory
    template_dir = os.path.join(
        os.path.dirname(os.path.abspath(__file__)),
        'jinja2',
        template_format
    )

    # Setup Jinja2 environment
    env = Environment(
        loader=FileSystemLoader(template_dir),
        trim_blocks=True,
        lstrip_blocks=True
    )

    # Add custom filters
    env.filters['round'] = lambda x, decimals=1: round(x, decimals)

    # Load and render template
    template = env.get_template('mssp_comprehensive.j2')
    rendered_content = template.render(**data)

    # Convert to PDF if requested
    if output_format == 'pdf':
        try:
            from weasyprint import HTML
            pdf_bytes = HTML(string=rendered_content).write_pdf()
            return pdf_bytes
        except ImportError:
            print("‚ö†Ô∏è  Warning: weasyprint not installed. Install with: pip3 install weasyprint")
            print("Returning HTML instead...")
            return rendered_content

    return rendered_content


# Legacy function stubs removed - now using Jinja2 templates
# The old format_markdown and format_html functions have been replaced
# with the render_report function above using Mermaid for all visualizations
            md.append("")

    # Detections
    det = data['detection_summary']
    md.append("## üîí Security Detections")
    md.append(f"- **Total Detections**: {det.get('total', 0)}")
    md.append(f"- **Average per Day**: {det.get('avg_per_day', 0)}\n")

    if det.get('by_category'):
        md.append("### Detection Categories")
        for cat, count in sorted(det['by_category'].items(), key=lambda x: x[1], reverse=True):
            md.append(f"- **{cat}**: {count}")
        md.append("")

    if det.get('top_rules'):
        md.append("### Top Detection Rules")
        md.append("| Rule | Count |")
        md.append("|------|-------|")
        for rule, count in det['top_rules'][:10]:
            rule_name = rule[:60] + '...' if len(rule) > 60 else rule
            md.append(f"| {rule_name} | {count} |")
        md.append("")

    if det.get('by_day'):
        md.append("### Detection Timeline")
        md.append("| Date | Detections |")
        md.append("|------|-----------|")
        for date, count in sorted(det['by_day'].items()):
            md.append(f"| {date} | {count} |")
        md.append("")

    # Usage
    if 'usage_summary' in data and 'error' not in data['usage_summary']:
        usage = data['usage_summary']
        md.append("## üìà Usage Statistics")
        md.append(f"**Period**: {usage.get('date_range', 'N/A')}\n")

        md.append("### Totals")
        totals = usage.get('totals', {})
        md.append(f"- **Total Events**: {totals.get('total_events', 0):,}")
        md.append(f"- **Total Evaluations**: {totals.get('total_evaluations', 0):,}")
        md.append(f"- **Total Output**: {totals.get('total_output_gb', 0)} GB\n")

        if usage['timeline'].get('events'):
            md.append("### Event Volume Timeline")
            md.append("| Date | Events |")
            md.append("|------|--------|")
            for entry in usage['timeline']['events'][-7:]:  # Last 7 days
                md.append(f"| {entry['date']} | {entry['events']:,} |")
            md.append("")

    # D&R Rules
    if 'dr_rules' in data and 'error' not in data['dr_rules']:
        md.append("## üõ°Ô∏è Detection & Response Rules")
        dr = data['dr_rules']
        md.append(f"- **Total Rules**: {dr.get('total', 0)}")
        md.append(f"- **Rule Namespaces**: {dr.get('namespaces', 0)}\n")

    # False Positives
    if 'false_positives' in data and 'error' not in data['false_positives']:
        fp = data['false_positives']
        md.append("## ‚úÖ False Positive Suppression")
        md.append(f"- **FP Rules**: {fp.get('total', 0)}\n")

    # Configuration
    config = data.get('config_summary', {})
    md.append("## ‚öôÔ∏è Configuration")
    md.append(f"- **Users**: {config.get('users', 'N/A')}")
    md.append(f"- **API Keys**: {config.get('api_keys', 'N/A')}")
    if 'outputs' in data:
        md.append(f"- **Outputs**: {data['outputs'].get('total', 'N/A')}")
    if 'tags' in data:
        md.append(f"- **Tags**: {data['tags'].get('total', 'N/A')}\n")

    md.append("---")
    md.append("*Generated by LimaCharlie Organization Reporting*")

    return '\n'.join(md)


def format_html(data, output_format='html'):
    """Format data as enhanced HTML report with charts"""

    meta = data['report_metadata']
    org = data['org_info']
    sensors = data['sensor_stats']
    det = data['detection_summary']
    config = data.get('config_summary', {})

    # Determine if we should use static charts (for PDF/Markdown) or interactive (for HTML)
    use_static_charts = should_use_static_charts(output_format)

    # Prepare chart data
    event_chart_data = []
    detection_chart_data = []

    if 'usage_summary' in data and 'error' not in data['usage_summary']:
        usage = data['usage_summary']
        if usage['timeline'].get('events'):
            event_chart_data = json.dumps([
                {'date': e['date'], 'value': e['events']}
                for e in usage['timeline']['events']
            ])

    if det.get('by_day'):
        detection_chart_data = json.dumps([
            {'date': date, 'value': count}
            for date, count in sorted(det['by_day'].items())
        ])

    html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>LimaCharlie Organization Report - {org.get('name', 'N/A')}</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            line-height: 1.6;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }}
        .header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 20px;
        }}
        .header h1 {{
            margin: 0 0 10px 0;
        }}
        .metadata {{
            opacity: 0.9;
            font-size: 0.9em;
        }}
        .card {{
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }}
        .card h2 {{
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }}
        .stats-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }}
        .stat-box {{
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #667eea;
        }}
        .stat-label {{
            color: #666;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }}
        .stat-value {{
            font-size: 1.8em;
            font-weight: bold;
            color: #333;
            margin-top: 5px;
        }}
        .status-good {{ border-left-color: #28a745; }}
        .status-warning {{ border-left-color: #ffc107; }}
        .status-danger {{ border-left-color: #dc3545; }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }}
        th, td {{
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }}
        th {{
            background: #f8f9fa;
            font-weight: 600;
        }}
        .chart-container {{
            position: relative;
            height: 300px;
            margin: 20px 0;
        }}
        .footer {{
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }}
        .alert {{
            padding: 12px;
            border-radius: 4px;
            margin: 10px 0;
        }}
        .alert-warning {{
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            color: #856404;
        }}
        .alert-danger {{
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            color: #721c24;
        }}
        .two-column {{
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }}
        .print-only {{
            display: none;
        }}
        @media (max-width: 768px) {{
            .two-column {{
                grid-template-columns: 1fr;
            }}
        }}
        @media print {{
            .print-only {{
                display: block;
            }}
            body {{
                max-width: 100%;
                padding: 10px;
                background: white;
            }}
            .card {{
                page-break-inside: avoid;
                box-shadow: none;
                border: 1px solid #ddd;
            }}
            .header {{
                page-break-after: avoid;
            }}
            table {{
                font-size: 0.85em;
                page-break-inside: avoid;
            }}
            th, td {{
                padding: 6px 8px;
                word-wrap: break-word;
                overflow-wrap: break-word;
            }}
            .chart-container {{
                display: none;
            }}
            .two-column {{
                grid-template-columns: 1fr;
            }}
            .stats-grid {{
                grid-template-columns: repeat(2, 1fr);
            }}
        }}
    </style>
</head>
<body>
    <div class="header">
        <h1>üõ°Ô∏è Comprehensive Organization Report</h1>
        <div class="metadata">
            <strong>{org.get('name', 'N/A')}</strong> |
            Generated: {meta['generated_at']} |
            Period: {meta['start_date']} to {meta['end_date']} ({meta['time_range_days']} days)
        </div>
    </div>

    <div class="card">
        <h2>üìä Key Metrics Dashboard</h2>
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-label">Total Sensors</div>
                <div class="stat-value">{sensors['total']}</div>
            </div>
            <div class="stat-box {'status-danger' if sensors['online_percentage'] < 80 else 'status-warning' if sensors['online_percentage'] < 95 else 'status-good'}">
                <div class="stat-label">Online Sensors</div>
                <div class="stat-value">{sensors['online']} <span style="font-size:0.5em">({sensors['online_percentage']}%)</span></div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Total Detections</div>
                <div class="stat-value">{det.get('total', 0)}</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Avg Detections/Day</div>
                <div class="stat-value">{det.get('avg_per_day', 0)}</div>
            </div>
        </div>

        {f'<div class="alert alert-danger"><strong>‚ö†Ô∏è Critical:</strong> Only {sensors["online_percentage"]}% of sensors are online. Immediate investigation required.</div>' if sensors['online_percentage'] < 80 else ''}
        {f'<div class="alert alert-warning"><strong>‚ö†Ô∏è Warning:</strong> {sensors["online_percentage"]}% sensor availability is below optimal (95%).</div>' if 80 <= sensors['online_percentage'] < 95 else ''}
    </div>

    <div class="two-column">
        <div class="card">
            <h2>üíª Sensor Health by Platform</h2>
            <table>
                <tr>
                    <th>Platform</th>
                    <th>Total</th>
                    <th>Online</th>
                    <th>Offline</th>
                    <th>Availability</th>
                </tr>
"""

    for platform in sorted(sensors.get('by_platform', {}).keys(), key=str):
        total = sensors['by_platform'][platform]
        online = sensors['online_by_platform'].get(platform, 0)
        offline = total - online
        avail = round((online/total*100) if total > 0 else 0, 1)
        status_class = 'status-good' if avail >= 95 else 'status-warning' if avail >= 80 else 'status-danger'

        html += f"""                <tr>
                    <td><strong>{platform}</strong></td>
                    <td>{total}</td>
                    <td>{online}</td>
                    <td>{offline}</td>
                    <td><span style="color: {'#28a745' if avail >= 95 else '#ffc107' if avail >= 80 else '#dc3545'}">{avail}%</span></td>
                </tr>
"""

    html += """            </table>
        </div>

        <div class="card">
            <h2>üîí Detection Summary</h2>
            <table>
                <tr>
                    <th>Metric</th>
                    <th>Value</th>
                </tr>
                <tr>
                    <td>Total Detections</td>
                    <td><strong>{:,}</strong></td>
                </tr>
                <tr>
                    <td>Average per Day</td>
                    <td><strong>{}</strong></td>
                </tr>
                <tr>
                    <td>Unique Categories</td>
                    <td><strong>{}</strong></td>
                </tr>
                <tr>
                    <td>Unique Rules Triggered</td>
                    <td><strong>{}</strong></td>
                </tr>
            </table>
        </div>
    </div>
""".format(
        det.get('total', 0),
        det.get('avg_per_day', 0),
        len(det.get('by_category', {})),
        len(det.get('top_rules', []))
    )

    # Detection timeline chart
    if det.get('by_day'):
        if use_static_charts:
            # Generate static chart for PDF
            chart_data_dict = {
                'labels': [date for date, count in sorted(det['by_day'].items())],
                'data': [count for date, count in sorted(det['by_day'].items())]
            }
            static_chart = generate_static_chart(chart_data_dict, 'line', 'Detection Timeline')

            if static_chart:
                html += f"""
    <div class="card">
        <h2>üìà Detection Timeline</h2>
        <div style="text-align: center; padding: 20px;">
            <img src="{static_chart}" style="max-width: 100%; height: auto;" alt="Detection Timeline Chart">
        </div>
    </div>
"""
            else:
                html += """
    <div class="card">
        <h2>üìà Detection Timeline</h2>
        <p style="color: #666; font-style: italic; padding: 20px; background: #f8f9fa; border-radius: 6px;">
            Chart data available in tabular format above.
        </p>
    </div>
"""
        else:
            # Interactive chart for HTML
            html += """
    <div class="card">
        <h2>üìà Detection Timeline</h2>
        <div class="chart-container">
            <canvas id="detectionChart"></canvas>
        </div>
    </div>
"""

    # Event volume chart
    if event_chart_data and event_chart_data != '[]':
        if use_static_charts:
            # Generate static chart for PDF
            try:
                event_data = json.loads(event_chart_data)
                chart_data_dict = {
                    'labels': [item['date'] for item in event_data],
                    'data': [item['value'] for item in event_data]
                }
                static_chart = generate_static_chart(chart_data_dict, 'line', 'Sensor Event Volume Timeline')

                if static_chart:
                    html += f"""
    <div class="card">
        <h2>üìä Sensor Event Volume Timeline</h2>
        <div style="text-align: center; padding: 20px;">
            <img src="{static_chart}" style="max-width: 100%; height: auto;" alt="Event Volume Timeline Chart">
        </div>
    </div>
"""
                else:
                    html += """
    <div class="card">
        <h2>üìä Sensor Event Volume Timeline</h2>
        <p style="color: #666; font-style: italic; padding: 20px; background: #f8f9fa; border-radius: 6px;">
            Chart data available in usage statistics section.
        </p>
    </div>
"""
            except:
                pass
        else:
            # Interactive chart for HTML
            html += """
    <div class="card">
        <h2>üìä Sensor Event Volume Timeline</h2>
        <div class="chart-container">
            <canvas id="eventChart"></canvas>
        </div>
    </div>
"""

    # Top detection rules
    if det.get('top_rules'):
        html += """
    <div class="card">
        <h2>üéØ Top Detection Rules</h2>
        <table>
            <tr>
                <th>#</th>
                <th>Rule Name</th>
                <th>Detections</th>
            </tr>
"""
        for i, (rule, count) in enumerate(det['top_rules'][:10], 1):
            rule_display = rule if len(rule) <= 80 else rule[:77] + '...'
            html += f"""            <tr>
                <td>{i}</td>
                <td>{rule_display}</td>
                <td><strong>{count}</strong></td>
            </tr>
"""
        html += """        </table>
    </div>
"""

    # Detection categories
    if det.get('by_category'):
        html += """
    <div class="card">
        <h2>üìã Detection Categories</h2>
        <table>
            <tr>
                <th>Category</th>
                <th>Count</th>
                <th>Percentage</th>
            </tr>
"""
        total_dets = det.get('total', 1)
        for cat, count in sorted(det['by_category'].items(), key=lambda x: x[1], reverse=True):
            pct = round((count / total_dets * 100), 1)
            html += f"""            <tr>
                <td><strong>{cat}</strong></td>
                <td>{count}</td>
                <td>{pct}%</td>
            </tr>
"""
        html += """        </table>
    </div>
"""

    # Usage stats
    if 'usage_summary' in data and 'error' not in data['usage_summary']:
        usage = data['usage_summary']
        totals = usage.get('totals', {})

        html += f"""
    <div class="card">
        <h2>üìà Usage Statistics Summary</h2>
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-label">Total Events</div>
                <div class="stat-value">{totals.get('total_events', 0):,}</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Total Evaluations</div>
                <div class="stat-value">{totals.get('total_evaluations', 0):,}</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Total Output</div>
                <div class="stat-value">{totals.get('total_output_gb', 0)} GB</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Avg Events/Day</div>
                <div class="stat-value">{int(totals.get('total_events', 0) / meta['time_range_days']):,}</div>
            </div>
        </div>
    </div>
"""

    # Configuration
    html += f"""
    <div class="card">
        <h2>‚öôÔ∏è Configuration Overview</h2>
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-label">D&R Rules</div>
                <div class="stat-value">{data.get('dr_rules', {}).get('total', 0)}</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Outputs</div>
                <div class="stat-value">{data.get('outputs', {}).get('total', 0)}</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Tags</div>
                <div class="stat-value">{data.get('tags', {}).get('total', 0)}</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Users</div>
                <div class="stat-value">{config.get('users', 0)}</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">API Keys</div>
                <div class="stat-value">{config.get('api_keys', 0)}</div>
            </div>
"""

    if 'false_positives' in data and 'error' not in data['false_positives']:
        html += f"""            <div class="stat-box">
                <div class="stat-label">FP Rules</div>
                <div class="stat-value">{data['false_positives'].get('total', 0)}</div>
            </div>
"""

    html += """        </div>
    </div>

    <div class="footer">
        Generated by LimaCharlie MSSP Comprehensive Reporting Skill
    </div>

    <script>
"""

    # Add chart scripts if we have data
    if detection_chart_data:
        html += f"""
        // Detection Timeline Chart
        const detectionData = {detection_chart_data};
        const detectionCtx = document.getElementById('detectionChart');
        if (detectionCtx) {{
            new Chart(detectionCtx, {{
                type: 'line',
                data: {{
                    labels: detectionData.map(d => d.date),
                    datasets: [{{
                        label: 'Detections',
                        data: detectionData.map(d => d.value),
                        borderColor: '#dc3545',
                        backgroundColor: 'rgba(220, 53, 69, 0.1)',
                        tension: 0.4,
                        fill: true
                    }}]
                }},
                options: {{
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {{
                        legend: {{
                            display: true,
                            position: 'top'
                        }}
                    }},
                    scales: {{
                        y: {{
                            beginAtZero: true
                        }}
                    }}
                }}
            }});
        }}
"""

    if event_chart_data and event_chart_data != '[]':
        html += f"""
        // Event Volume Chart
        const eventData = {event_chart_data};
        const eventCtx = document.getElementById('eventChart');
        if (eventCtx) {{
            new Chart(eventCtx, {{
                type: 'bar',
                data: {{
                    labels: eventData.map(d => d.date),
                    datasets: [{{
                        label: 'Sensor Events',
                        data: eventData.map(d => d.value),
                        backgroundColor: '#667eea',
                        borderColor: '#764ba2',
                        borderWidth: 1
                    }}]
                }},
                options: {{
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {{
                        legend: {{
                            display: true,
                            position: 'top'
                        }}
                    }},
                    scales: {{
                        y: {{
                            beginAtZero: true
                        }}
                    }}
                }}
            }});
        }}
"""

    html += """
    </script>
</body>
</html>
"""

    return html


if __name__ == '__main__':
    import sys

    if len(sys.argv) < 2:
        print("Usage: python mssp_comprehensive_report.py <OID> [days] [format]")
        print("  format: html (default), markdown, pdf, or json")
        print("Example: python mssp_comprehensive_report.py 8cbe27f4-bfa1-4afb-ba19-138cd51389cd 7 html")
        sys.exit(1)

    oid = sys.argv[1]
    days = int(sys.argv[2]) if len(sys.argv) > 2 else 7
    fmt = sys.argv[3] if len(sys.argv) > 3 else 'html'

    # Validate format
    if fmt not in ['html', 'markdown', 'pdf', 'json']:
        print(f"Error: Invalid format '{fmt}'. Must be html, markdown, pdf, or json")
        sys.exit(1)

    # For PDF, generate HTML first then convert
    report_format = 'html' if fmt == 'pdf' else fmt
    report = generate_mssp_report(oid, days, report_format)

    # Convert to PDF if requested
    if fmt == 'pdf':
        try:
            from weasyprint import HTML
            pdf_bytes = HTML(string=report).write_pdf()
            report = pdf_bytes
        except ImportError:
            print("‚ö†Ô∏è  Warning: weasyprint not installed. Install with: pip3 install weasyprint")
            print("Falling back to HTML output...")
            fmt = 'html'

    # Save to file
    ext = 'html' if fmt == 'html' else 'md' if fmt == 'markdown' else 'pdf' if fmt == 'pdf' else 'json'
    filename = f'mssp_report_{datetime.now().strftime("%Y%m%d_%H%M%S")}.{ext}'

    # Write binary for PDF, text for others
    mode = 'wb' if isinstance(report, bytes) else 'w'
    with open(filename, mode) as f:
        f.write(report)

    print(f"\n‚úì Report saved to: {filename}")
