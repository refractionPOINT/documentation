"""
Report Formatters
Functions for rendering reports in various output formats
"""

import json
import os
from datetime import datetime, timezone
from jinja2 import Environment, FileSystemLoader
from .constants import FORMAT_EXTENSIONS


def render_html_report(data, template_name, template_dir=None):
    """
    Render report using Jinja2 HTML template

    Args:
        data: Dictionary of data to pass to template
        template_name: Name of the template file (e.g., 'security_detections.j2')
        template_dir: Directory containing templates (optional, auto-detected if None)

    Returns:
        Rendered HTML as string
    """
    # Auto-detect template directory if not provided
    if template_dir is None:
        script_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        template_dir = os.path.join(script_dir, 'jinja2', 'html')

    # Setup Jinja2 environment
    env = Environment(
        loader=FileSystemLoader(template_dir),
        trim_blocks=True,
        lstrip_blocks=True
    )

    # Load and render template
    template = env.get_template(template_name)
    return template.render(**data)


def render_markdown_report(data, title='Report'):
    """
    Render report as Markdown

    Args:
        data: Dictionary of report data
        title: Report title

    Returns:
        Markdown-formatted report as string
    """
    md = []
    md.append(f"# {title}\\n")

    # Metadata section
    if 'report_metadata' in data:
        meta = data['report_metadata']
        md.append(f"**Generated**: {meta.get('generated_at', 'N/A')}")
        md.append(f"**Report Type**: {meta.get('report_type', 'N/A')}\\n")

    # Organization info
    if 'org_info' in data:
        org = data['org_info']
        md.append(f"**Organization**: {org.get('name', 'N/A')} ({org.get('oid', 'N/A')})\\n")

    # Add custom sections based on data keys
    section_handlers = {
        'investigation_scope': _format_investigation_scope_md,
        'detections': _format_detections_md,
        'sensors': _format_sensors_md,
        'rules': _format_rules_md,
        'recommendations': _format_recommendations_md
    }

    for key, handler in section_handlers.items():
        if key in data:
            section_md = handler(data[key])
            if section_md:
                md.extend(section_md)

    md.append("---")
    md.append("*Generated by LimaCharlie Reporting Framework*")

    return '\\n'.join(md)


def _format_investigation_scope_md(scope):
    """Format investigation scope section for Markdown"""
    md = []
    md.append("## Investigation Scope")
    md.append(f"- **Time Range**: {scope.get('start_date', 'N/A')} to {scope.get('end_date', 'N/A')}")
    md.append(f"- **Duration**: {scope.get('duration_hours', 'N/A')} hours")
    if scope.get('sensor_id'):
        md.append(f"- **Target Sensor**: {scope['sensor_id']}")
    if scope.get('detection_category'):
        md.append(f"- **Detection Category**: {scope['detection_category']}")
    md.append("")
    return md


def _format_detections_md(detections):
    """Format detections section for Markdown"""
    md = []
    md.append("## Detections Summary")
    md.append(f"- **Total Detections**: {detections.get('total', 0)}")
    md.append(f"- **Affected Sensors**: {detections.get('affected_sensor_count', 0)}")

    if detections.get('by_category'):
        md.append("\\n### Top Detection Categories")
        sorted_cats = sorted(
            detections['by_category'].items(),
            key=lambda x: x[1],
            reverse=True
        )[:10]
        for cat, count in sorted_cats:
            md.append(f"- **{cat}**: {count}")

    md.append("")
    return md


def _format_sensors_md(sensors):
    """Format sensors section for Markdown"""
    md = []
    md.append("## Sensor Summary")
    md.append(f"- **Total Sensors**: {sensors.get('total', 0)}")
    md.append(f"- **Online**: {sensors.get('online_count', 0)}")
    md.append(f"- **Offline**: {sensors.get('offline_count', 0)}")

    if sensors.get('by_platform'):
        md.append("\\n### By Platform")
        for platform, count in sensors['by_platform'].items():
            md.append(f"- **{platform}**: {count}")

    md.append("")
    return md


def _format_rules_md(rules):
    """Format rules section for Markdown"""
    md = []
    md.append("## D&R Rules Summary")
    md.append(f"- **Total Rules**: {rules.get('total', 0)}")
    md.append(f"- **Enabled**: {rules.get('enabled_count', 0)}")
    md.append(f"- **Disabled**: {rules.get('disabled_count', 0)}")

    if rules.get('by_namespace'):
        md.append("\\n### By Namespace")
        sorted_ns = sorted(
            rules['by_namespace'].items(),
            key=lambda x: x[1],
            reverse=True
        )[:10]
        for ns, count in sorted_ns:
            md.append(f"- **{ns}**: {count}")

    md.append("")
    return md


def _format_recommendations_md(recommendations):
    """Format recommendations section for Markdown"""
    md = []
    md.append("## Recommendations")
    for rec in recommendations:
        priority = rec.get('priority', 'medium').upper()
        category = rec.get('category', 'General')
        recommendation = rec.get('recommendation', '')
        md.append(f"- **[{priority}]** {category}: {recommendation}")
    md.append("")
    return md


def render_json_report(data, indent=2):
    """
    Render report as JSON

    Args:
        data: Dictionary of report data
        indent: JSON indentation (default: 2)

    Returns:
        JSON-formatted report as string
    """
    return json.dumps(data, indent=indent, default=str)


def save_report(content, output_format='html', prefix='report', output_dir=None):
    """
    Save report to file

    Args:
        content: Report content as string
        output_format: File format ('html', 'markdown', 'json', 'csv')
        prefix: Filename prefix (default: 'report')
        output_dir: Output directory (default: project_root/reports)

    Returns:
        Path to saved report file
    """
    # Determine output directory
    if output_dir is None:
        script_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        project_root = os.path.abspath(os.path.join(script_dir, '../../../..'))
        output_dir = os.path.join(project_root, 'reports')

    # Create output directory if needed
    os.makedirs(output_dir, exist_ok=True)

    # Determine file extension from constants
    ext = FORMAT_EXTENSIONS.get(output_format, 'txt')

    # Generate filename with timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f'{prefix}_{timestamp}.{ext}'
    filepath = os.path.join(output_dir, filename)

    # Write file
    with open(filepath, 'w') as f:
        f.write(content)

    return filepath


def add_report_metadata(data, report_type='Generic Report'):
    """
    Add standard metadata to report data

    Args:
        data: Report data dictionary (modified in-place)
        report_type: Type of report

    Returns:
        Modified data dictionary
    """
    data['report_metadata'] = {
        'generated_at': datetime.now(timezone.utc).isoformat(),
        'report_type': report_type
    }
    return data


__all__ = [
    'render_html_report',
    'render_markdown_report',
    'render_json_report',
    'save_report',
    'add_report_metadata'
]
